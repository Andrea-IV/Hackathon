
//----------------- REQUIREMENTS

//Prédicat disant si un document est de type exigence
METHOD AbstractDocument.isRequirementDocument() : category $< "Functional Specification" $+ "Domain Specification";

//Prédicat disant si un élément est de type exigence
METHOD AbstractRequirement.isRequirement() : NOT isUnknown AND document.isRequirementDocument;

// Scope d'une exigence (type de document)
METHOD AbstractRequirement.getRequirementScope() : STRSEARCHRE(ident, "^([^_]+)");
	
// Récupération de la liste des sous-ensembles couvrant une exigence
METHOD AbstractRequirement.getCoveredAllocations() : {
	requirementReferencers[isRequirement].getRequirementScope.SELECTUNIQUE(EACH)
	};

// Récupération de la liste des allocations d'une exigence
METHOD AbstractRequirement.getAllocations() : {
	attributes[typeName="Allocation"].ident;
	};

// Récupération de la liste des allocations non couvertes
METHOD AbstractRequirement.getUncoveredAllocations() : getAllocations $- getCoveredAllocations;

// Récupération de la liste des couvertures non requises par des allocations
METHOD AbstractRequirement.getUnexpectedCoverage() : getCoveredAllocations $- getAllocations;

// Prédicat disant si une exigence est satisfaite (avec ou sans allocations)
METHOD AbstractRequirement.isSatisfied () : {
	$NO (attributes[typeName="Allocation"]) 
	IF TRUE : $SOME(requirementReferencers[isRequirement])
	ELSE : $NO(getUncoveredAllocations)
	};

// Prédicat disant si une exigence doit être satisfaite
METHOD AbstractRequirement.mustBeSatisfied () : $SOME(document.coveringDocuments[isRequirementDocument]);

//------------------------------ TESTS

//Prédicat disant si un document est de type exigence
METHOD AbstractDocument.isValidationDocument() : category = "Test Plan";

// Prédicat disant si un élément est de type test
METHOD AbstractRequirement.isTest() : NOT isUnknown AND document.isValidationDocument;

//-----------------A modifier en se basant sur le choix de définition de type de test ACTIA
// Type d'un test
METHOD AbstractRequirement.getTestType() : {
	STRSEARCHRE(ident, "^([^_]+)")
	IF "VAL" : "Testing"
	IF "QLF" : "Qualification Test"
	ELSE : "None"
};

//Récupération de la liste des types de test qui couvrent un req
METHOD AbstractRequirement.getCoveredTestTypes() : {
	requirementReferencers[isTest].getTestType.SELECTUNIQUE(EACH)
	};

//Récupération de la liste des types d'un test (V&V)
METHOD AbstractRequirement.getTestTypes() : {
	attributes[typeName="Test Type"].ident;
	};
	
// Récupération de la liste des types de tests requis et non couverts
METHOD AbstractRequirement.getUncoveredTestTypes() : getTestTypes $- getCoveredTestTypes;

// Récupération de la liste des types de tests couvrant non requis 
METHOD AbstractRequirement.getUnexpectedTestTypes() : getCoveredTestTypes $- getTestTypes;

//Identification d'une exigence si elle est couverte par un test (avec ou sans type de test définis)
METHOD AbstractRequirement.isValidated () : {
	$NO (attributes[typeName="V&V"]) 
	IF TRUE : $SOME(requirementReferencers[isTest])
	ELSE : $NO(getUncoveredTestTypes)
	};

	// Prédicat disant si une exigence doit être validée
METHOD AbstractRequirement.mustBeValidated () : $SOME(document.coveringDocuments[isValidationDocument]);

//-------------------------------RULES


// Règle : chaque allocation doit être satisfaite par un lien de couverture
RULE Requirement.uncoveredAllocation -e1 : {
	NOT isRequirement OR $NO(getUncoveredAllocations)
} LABEL "Uncovered allocation"|"Allocation non couverte" EXPLAIN $STRSEP(getUncoveredAllocations, ", ");

// Règle : chaque couverture doit correspondre à une allocation
RULE Requirement.unexpectedCoverage -e2 : {
	NOT isRequirement OR $NO(getUnexpectedCoverage)
} LABEL "Unexpected coverage from allocation"|"Couverture non prévue par l'allocation" EXPLAIN $STRSEP(getUnexpectedCoverage, ", ");

// Règle : chaque Test type doit être satisfaite par un lien de couverture
RULE Requirement.uncoveredTestType -e1 : {
	NOT isRequirement OR $NO(getUncoveredTestTypes)
} LABEL "Uncovered test types"|"Types de test non couverts" EXPLAIN $STRSEP(getUncoveredTestTypes, ", ");

// Règle : chaque couverture doit correspondre à un test type
RULE Requirement.unexpectedTestType -e2 : {
	NOT isRequirement OR $NO(getUnexpectedTestTypes)
} LABEL "Unexpected coverage from test types"|"Types de test non prévus" EXPLAIN $STRSEP(getUnexpectedTestTypes, ", ");

// Redéfinition de la règle "Uncovered requirement" pour prendre en compte l'allocation
RULE AbstractRequirement.uncovered -e1 : {
	isRequirement
	IF TRUE : {(NOT mustBeSatisfied OR isSatisfied) AND (NOT mustBeValidated OR isValidated)}
	ELSE : {isBasicallyCovered};
} LABEL "Uncovered requirement"|"Exigence non couverte";


//--------------------------------- COVERAGE RATIOS

// Compute coverage taking allocation into account
METHOD Cover.computeCoveringRatioWithAllocation() : {
	TMP divisor := 1;
	TMP ratio : Real;
	TMP reqsToCover := coveredDocument.requirements;
	
	$SOME(reqsToCover) IF TRUE : {divisor := $CNT(reqsToCover)};
	ratio := $CNT(reqsToCover[$NO(getUncoveredAllocations)]) * 100.0 / divisor;
	STRSEARCHRE(STR(ratio), "^(\d+\.?\d?)")
};

// Compute coverage taking test types into account
METHOD Cover.computeCoveringRatioWithTestTypes() : {
	TMP divisor := 1;
	TMP ratio : Real;
	TMP reqsToCover := coveredDocument.requirements;
	
	$SOME(reqsToCover) IF TRUE : {divisor := $CNT(reqsToCover)};
	ratio := $CNT(reqsToCover[$NO(getUncoveredTestTypes)]) * 100.0 / divisor;
	STRSEARCHRE(STR(ratio), "^(\d+\.?\d?)")
};

// Redefine coverage ratios in management view for satisfaction of SES
METHOD Cover.managementCoverLabel() : {
	(coveredDocument.isRequirementDocument AND $SOME(coveringDocuments[isRequirementDocument]))
	IF TRUE : {
		STRF("$1%", computeCoveringRatioWithAllocation)
	} ELSE : {
		(coveredDocument.isRequirementDocument AND $SOME(coveringDocuments[isValidationDocument]))
		IF TRUE : {
			STRF("$1%", computeCoveringRatioWithTestTypes)
		} ELSE : {
			STRF("$1%", computeCoveringRatio)
		};
	};
};